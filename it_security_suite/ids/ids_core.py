#!/usr/bin/env python3
"""
===============================================================================
ELECTRODUCTION INTRUSION DETECTION SYSTEM (IDS)
===============================================================================
A complete, educational IDS implementation demonstrating:
- Signature-based detection (pattern matching)
- Anomaly-based detection (statistical analysis)
- Protocol analysis and validation
- Port scan detection
- DDoS detection
- Malware signature matching
- Real-time alerting
- Log correlation
- Network traffic analysis

This IDS uses:
- Regular expressions for signature matching
- Statistical models for anomaly detection
- Sliding window algorithms for rate analysis
- Machine learning concepts for behavior analysis
===============================================================================
"""

import os
import sys
import socket
import struct
import threading
import time
import json
import logging
import hashlib
import re
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple, Set, Callable, Any
from enum import Enum, auto
from collections import defaultdict, deque
from datetime import datetime, timedelta
import statistics
import math

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('IDS')


class Severity(Enum):
    """Alert severity levels"""
    INFO = 1
    LOW = 2
    MEDIUM = 3
    HIGH = 4
    CRITICAL = 5


class AlertType(Enum):
    """Types of security alerts"""
    SIGNATURE_MATCH = auto()
    ANOMALY_DETECTED = auto()
    PORT_SCAN = auto()
    BRUTE_FORCE = auto()
    DDOS_ATTACK = auto()
    PROTOCOL_VIOLATION = auto()
    MALWARE_DETECTED = auto()
    SUSPICIOUS_PAYLOAD = auto()
    POLICY_VIOLATION = auto()
    DATA_EXFILTRATION = auto()


class Protocol(Enum):
    """Network protocols"""
    ANY = 0
    ICMP = 1
    TCP = 6
    UDP = 17


@dataclass
class Alert:
    """Security alert generated by the IDS"""
    id: str
    timestamp: float
    alert_type: AlertType
    severity: Severity
    source_ip: str
    destination_ip: str
    source_port: Optional[int]
    destination_port: Optional[int]
    protocol: Protocol
    description: str
    signature_id: Optional[str] = None
    raw_packet: Optional[bytes] = None
    additional_info: Dict = field(default_factory=dict)

    def to_dict(self) -> Dict:
        """Convert alert to dictionary"""
        return {
            'id': self.id,
            'timestamp': datetime.fromtimestamp(self.timestamp).isoformat(),
            'type': self.alert_type.name,
            'severity': self.severity.name,
            'source': f"{self.source_ip}:{self.source_port}",
            'destination': f"{self.destination_ip}:{self.destination_port}",
            'protocol': self.protocol.name,
            'description': self.description,
            'signature_id': self.signature_id,
            'info': self.additional_info
        }


@dataclass
class Signature:
    """IDS detection signature"""
    id: str
    name: str
    severity: Severity
    description: str

    # Match criteria
    protocol: Protocol = Protocol.ANY
    src_port: Optional[int] = None
    dst_port: Optional[int] = None

    # Content matching
    content: Optional[bytes] = None
    content_pattern: Optional[str] = None  # Regex pattern
    content_offset: int = 0
    content_depth: int = 0  # 0 = entire payload

    # Flags
    nocase: bool = False
    pcre: Optional[str] = None  # Perl-compatible regex

    # Metadata
    category: str = "misc"
    cve: Optional[str] = None
    references: List[str] = field(default_factory=list)

    # Match count
    matches: int = 0


@dataclass
class PacketInfo:
    """Parsed packet information for IDS analysis"""
    raw: bytes
    timestamp: float
    src_ip: str
    dst_ip: str
    src_port: Optional[int]
    dst_port: Optional[int]
    protocol: Protocol
    payload: bytes
    flags: int = 0  # TCP flags
    packet_size: int = 0

    @classmethod
    def parse(cls, data: bytes) -> 'PacketInfo':
        """Parse raw packet data"""
        if len(data) < 20:
            raise ValueError("Packet too short")

        # Parse IP header
        version = (data[0] >> 4) & 0xF
        ihl = data[0] & 0xF
        ip_header_len = ihl * 4

        protocol_num = data[9]
        src_ip = socket.inet_ntoa(data[12:16])
        dst_ip = socket.inet_ntoa(data[16:20])

        protocol = Protocol(protocol_num) if protocol_num in [p.value for p in Protocol] else Protocol.ANY

        src_port = None
        dst_port = None
        payload = b''
        flags = 0

        transport_data = data[ip_header_len:]

        if protocol == Protocol.TCP and len(transport_data) >= 20:
            src_port = struct.unpack('!H', transport_data[0:2])[0]
            dst_port = struct.unpack('!H', transport_data[2:4])[0]
            data_offset = (transport_data[12] >> 4) * 4
            flags = transport_data[13]
            payload = transport_data[data_offset:]

        elif protocol == Protocol.UDP and len(transport_data) >= 8:
            src_port = struct.unpack('!H', transport_data[0:2])[0]
            dst_port = struct.unpack('!H', transport_data[2:4])[0]
            payload = transport_data[8:]

        elif protocol == Protocol.ICMP and len(transport_data) >= 4:
            payload = transport_data[4:]

        return cls(
            raw=data,
            timestamp=time.time(),
            src_ip=src_ip,
            dst_ip=dst_ip,
            src_port=src_port,
            dst_port=dst_port,
            protocol=protocol,
            payload=payload,
            flags=flags,
            packet_size=len(data)
        )


class SignatureEngine:
    """
    Signature-based detection engine.
    Matches packets against known attack signatures.
    """

    def __init__(self):
        self.signatures: Dict[str, Signature] = {}
        self._compiled_patterns: Dict[str, re.Pattern] = {}

    def load_signature(self, sig: Signature):
        """Load a signature into the engine"""
        self.signatures[sig.id] = sig

        # Compile regex patterns
        if sig.content_pattern:
            flags = re.IGNORECASE if sig.nocase else 0
            self._compiled_patterns[sig.id] = re.compile(
                sig.content_pattern.encode() if isinstance(sig.content_pattern, str) else sig.content_pattern,
                flags
            )

        if sig.pcre:
            flags = re.IGNORECASE if sig.nocase else 0
            self._compiled_patterns[f"{sig.id}_pcre"] = re.compile(
                sig.pcre.encode() if isinstance(sig.pcre, str) else sig.pcre,
                flags
            )

        logger.debug(f"Loaded signature: {sig.id} - {sig.name}")

    def load_default_signatures(self):
        """Load default detection signatures"""
        default_sigs = [
            # SQL Injection
            Signature(
                id="SQL_INJECTION_1",
                name="SQL Injection Attempt - UNION SELECT",
                severity=Severity.HIGH,
                description="Detects SQL injection using UNION SELECT",
                protocol=Protocol.TCP,
                content_pattern=rb"(?i)union\s+(?:all\s+)?select",
                category="sql-injection"
            ),
            Signature(
                id="SQL_INJECTION_2",
                name="SQL Injection Attempt - OR 1=1",
                severity=Severity.HIGH,
                description="Detects SQL injection using OR 1=1",
                protocol=Protocol.TCP,
                content_pattern=rb"(?i)'\s*or\s+['\"]?1['\"]?\s*=\s*['\"]?1",
                category="sql-injection"
            ),

            # XSS
            Signature(
                id="XSS_1",
                name="Cross-Site Scripting Attempt",
                severity=Severity.HIGH,
                description="Detects XSS script injection",
                protocol=Protocol.TCP,
                content_pattern=rb"(?i)<script[^>]*>",
                category="xss"
            ),
            Signature(
                id="XSS_2",
                name="XSS Event Handler Injection",
                severity=Severity.MEDIUM,
                description="Detects XSS using event handlers",
                protocol=Protocol.TCP,
                content_pattern=rb"(?i)on(?:error|load|click|mouse)\s*=",
                category="xss"
            ),

            # Command Injection
            Signature(
                id="CMD_INJECTION_1",
                name="Command Injection Attempt",
                severity=Severity.CRITICAL,
                description="Detects command injection using shell metacharacters",
                protocol=Protocol.TCP,
                content_pattern=rb";\s*(?:cat|ls|pwd|whoami|id|uname|wget|curl)\s",
                category="command-injection"
            ),

            # Path Traversal
            Signature(
                id="PATH_TRAVERSAL_1",
                name="Path Traversal Attempt",
                severity=Severity.HIGH,
                description="Detects directory traversal attacks",
                protocol=Protocol.TCP,
                content_pattern=rb"(?:\.\./){2,}|(?:%2e%2e%2f){2,}",
                nocase=True,
                category="path-traversal"
            ),

            # Shellshock
            Signature(
                id="SHELLSHOCK_1",
                name="Shellshock Exploit Attempt",
                severity=Severity.CRITICAL,
                description="Detects Shellshock (CVE-2014-6271) exploit",
                protocol=Protocol.TCP,
                content_pattern=rb"\(\s*\)\s*{\s*[^}]*;\s*}\s*;",
                cve="CVE-2014-6271",
                category="exploit"
            ),

            # HTTP Specific
            Signature(
                id="HTTP_METHODS_1",
                name="Suspicious HTTP Method",
                severity=Severity.MEDIUM,
                description="Detects unusual HTTP methods",
                protocol=Protocol.TCP,
                dst_port=80,
                content_pattern=rb"^(?:TRACE|TRACK|OPTIONS|DEBUG)\s",
                category="http"
            ),

            # Malware Indicators
            Signature(
                id="MALWARE_1",
                name="Potential Malware Download",
                severity=Severity.HIGH,
                description="Detects potential malware file extensions in requests",
                protocol=Protocol.TCP,
                content_pattern=rb"(?i)\.(?:exe|dll|bat|ps1|vbs|scr)\s*(?:HTTP|$)",
                category="malware"
            ),

            # Reconnaissance
            Signature(
                id="RECON_1",
                name="Nmap Scan Detection",
                severity=Severity.MEDIUM,
                description="Detects Nmap user agent",
                protocol=Protocol.TCP,
                content_pattern=rb"Nmap",
                category="reconnaissance"
            ),

            # Web Shells
            Signature(
                id="WEBSHELL_1",
                name="PHP Webshell Indicator",
                severity=Severity.CRITICAL,
                description="Detects common PHP webshell patterns",
                protocol=Protocol.TCP,
                content_pattern=rb"(?i)(?:eval|assert|passthru|exec|system)\s*\(\s*\$_(?:GET|POST|REQUEST)",
                category="webshell"
            ),

            # Sensitive Data
            Signature(
                id="DATA_LEAK_1",
                name="Credit Card Number Pattern",
                severity=Severity.CRITICAL,
                description="Detects potential credit card numbers",
                protocol=Protocol.TCP,
                content_pattern=rb"\b(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13})\b",
                category="data-leak"
            ),
            Signature(
                id="DATA_LEAK_2",
                name="Social Security Number Pattern",
                severity=Severity.CRITICAL,
                description="Detects potential SSN patterns",
                protocol=Protocol.TCP,
                content_pattern=rb"\b\d{3}-\d{2}-\d{4}\b",
                category="data-leak"
            ),
        ]

        for sig in default_sigs:
            self.load_signature(sig)

        logger.info(f"Loaded {len(default_sigs)} default signatures")

    def check_packet(self, packet: PacketInfo) -> List[Tuple[Signature, str]]:
        """
        Check packet against all signatures.
        Returns list of (signature, matched_content) tuples.
        """
        matches = []

        for sig_id, sig in self.signatures.items():
            # Protocol check
            if sig.protocol != Protocol.ANY and sig.protocol != packet.protocol:
                continue

            # Port checks
            if sig.src_port and packet.src_port != sig.src_port:
                continue
            if sig.dst_port and packet.dst_port != sig.dst_port:
                continue

            # Content matching
            search_data = packet.payload

            if sig.content_offset > 0:
                search_data = search_data[sig.content_offset:]

            if sig.content_depth > 0:
                search_data = search_data[:sig.content_depth]

            # Exact content match
            if sig.content:
                content = sig.content
                if sig.nocase:
                    content = content.lower()
                    search_data_check = search_data.lower()
                else:
                    search_data_check = search_data

                if content in search_data_check:
                    sig.matches += 1
                    matches.append((sig, content.decode('utf-8', errors='ignore')))
                    continue

            # Regex pattern match
            pattern = self._compiled_patterns.get(sig_id)
            if pattern:
                match = pattern.search(search_data)
                if match:
                    sig.matches += 1
                    matches.append((sig, match.group().decode('utf-8', errors='ignore')))
                    continue

            # PCRE match
            pcre_pattern = self._compiled_patterns.get(f"{sig_id}_pcre")
            if pcre_pattern:
                match = pcre_pattern.search(search_data)
                if match:
                    sig.matches += 1
                    matches.append((sig, match.group().decode('utf-8', errors='ignore')))

        return matches


class AnomalyEngine:
    """
    Anomaly-based detection engine.
    Uses statistical analysis to detect unusual behavior.
    """

    def __init__(self, window_size: int = 1000):
        self.window_size = window_size

        # Traffic baselines
        self.packet_sizes: deque = deque(maxlen=window_size)
        self.packets_per_second: deque = deque(maxlen=60)
        self.unique_ports: deque = deque(maxlen=window_size)

        # Per-IP statistics
        self.ip_stats: Dict[str, Dict] = defaultdict(lambda: {
            'packet_count': 0,
            'byte_count': 0,
            'unique_ports': set(),
            'protocols': defaultdict(int),
            'last_seen': 0,
            'first_seen': 0
        })

        # Thresholds (can be adjusted)
        self.thresholds = {
            'packet_size_std_multiplier': 3.0,
            'pps_std_multiplier': 3.0,
            'port_scan_threshold': 20,  # Unique ports in short time
            'connection_rate_threshold': 100,  # Connections per second
            'large_packet_threshold': 1500,  # MTU
            'small_packet_flood_threshold': 100,  # Small packets/second
        }

        # Timing
        self._last_second = int(time.time())
        self._current_second_packets = 0

        self._lock = threading.Lock()

    def analyze_packet(self, packet: PacketInfo) -> List[Tuple[AlertType, str, Severity]]:
        """
        Analyze packet for anomalies.
        Returns list of (alert_type, description, severity) tuples.
        """
        anomalies = []

        with self._lock:
            # Update statistics
            self._update_stats(packet)

            # Check for various anomalies
            anomalies.extend(self._check_size_anomaly(packet))
            anomalies.extend(self._check_rate_anomaly(packet))
            anomalies.extend(self._check_port_scan(packet))
            anomalies.extend(self._check_protocol_anomaly(packet))

        return anomalies

    def _update_stats(self, packet: PacketInfo):
        """Update internal statistics with packet data"""
        # Packet size tracking
        self.packet_sizes.append(packet.packet_size)

        # Packets per second tracking
        current_second = int(time.time())
        if current_second != self._last_second:
            self.packets_per_second.append(self._current_second_packets)
            self._current_second_packets = 0
            self._last_second = current_second
        self._current_second_packets += 1

        # Port tracking
        if packet.dst_port:
            self.unique_ports.append(packet.dst_port)

        # Per-IP stats
        src_stats = self.ip_stats[packet.src_ip]
        src_stats['packet_count'] += 1
        src_stats['byte_count'] += packet.packet_size
        if packet.dst_port:
            src_stats['unique_ports'].add(packet.dst_port)
        src_stats['protocols'][packet.protocol] += 1
        src_stats['last_seen'] = packet.timestamp
        if src_stats['first_seen'] == 0:
            src_stats['first_seen'] = packet.timestamp

    def _check_size_anomaly(self, packet: PacketInfo) -> List[Tuple[AlertType, str, Severity]]:
        """Check for packet size anomalies"""
        anomalies = []

        if len(self.packet_sizes) < 100:
            return anomalies

        mean_size = statistics.mean(self.packet_sizes)
        std_size = statistics.stdev(self.packet_sizes) if len(self.packet_sizes) > 1 else 0

        if std_size > 0:
            z_score = (packet.packet_size - mean_size) / std_size
            if abs(z_score) > self.thresholds['packet_size_std_multiplier']:
                anomalies.append((
                    AlertType.ANOMALY_DETECTED,
                    f"Unusual packet size: {packet.packet_size} bytes (z-score: {z_score:.2f})",
                    Severity.LOW
                ))

        # Very large packet
        if packet.packet_size > self.thresholds['large_packet_threshold']:
            anomalies.append((
                AlertType.ANOMALY_DETECTED,
                f"Large packet detected: {packet.packet_size} bytes",
                Severity.MEDIUM
            ))

        return anomalies

    def _check_rate_anomaly(self, packet: PacketInfo) -> List[Tuple[AlertType, str, Severity]]:
        """Check for traffic rate anomalies"""
        anomalies = []

        if len(self.packets_per_second) < 30:
            return anomalies

        mean_pps = statistics.mean(self.packets_per_second)
        std_pps = statistics.stdev(self.packets_per_second) if len(self.packets_per_second) > 1 else 0

        current_pps = self._current_second_packets

        if std_pps > 0 and mean_pps > 0:
            z_score = (current_pps - mean_pps) / std_pps
            if z_score > self.thresholds['pps_std_multiplier']:
                anomalies.append((
                    AlertType.DDOS_ATTACK,
                    f"Traffic spike detected: {current_pps} pps (normal: {mean_pps:.1f})",
                    Severity.HIGH
                ))

        return anomalies

    def _check_port_scan(self, packet: PacketInfo) -> List[Tuple[AlertType, str, Severity]]:
        """Check for port scanning activity"""
        anomalies = []

        src_stats = self.ip_stats[packet.src_ip]
        duration = packet.timestamp - src_stats['first_seen']

        if duration > 0 and duration < 60:  # Within 1 minute
            unique_ports = len(src_stats['unique_ports'])
            if unique_ports > self.thresholds['port_scan_threshold']:
                anomalies.append((
                    AlertType.PORT_SCAN,
                    f"Port scan detected from {packet.src_ip}: {unique_ports} unique ports in {duration:.1f}s",
                    Severity.MEDIUM
                ))

        return anomalies

    def _check_protocol_anomaly(self, packet: PacketInfo) -> List[Tuple[AlertType, str, Severity]]:
        """Check for protocol anomalies"""
        anomalies = []

        # TCP flag anomalies
        if packet.protocol == Protocol.TCP:
            flags = packet.flags

            # Christmas tree scan (all flags set)
            if flags & 0x3F == 0x3F:
                anomalies.append((
                    AlertType.PORT_SCAN,
                    "Christmas tree scan detected (all TCP flags set)",
                    Severity.HIGH
                ))

            # Null scan (no flags)
            if flags == 0:
                anomalies.append((
                    AlertType.PORT_SCAN,
                    "Null scan detected (no TCP flags)",
                    Severity.MEDIUM
                ))

            # FIN scan
            if flags == 0x01:
                anomalies.append((
                    AlertType.PORT_SCAN,
                    "FIN scan detected",
                    Severity.MEDIUM
                ))

        return anomalies

    def get_baseline_stats(self) -> Dict:
        """Get current baseline statistics"""
        with self._lock:
            return {
                'mean_packet_size': statistics.mean(self.packet_sizes) if self.packet_sizes else 0,
                'std_packet_size': statistics.stdev(self.packet_sizes) if len(self.packet_sizes) > 1 else 0,
                'mean_pps': statistics.mean(self.packets_per_second) if self.packets_per_second else 0,
                'std_pps': statistics.stdev(self.packets_per_second) if len(self.packets_per_second) > 1 else 0,
                'unique_ips': len(self.ip_stats),
                'sample_size': len(self.packet_sizes)
            }


class BruteForceDetector:
    """Detects brute force attacks (SSH, FTP, HTTP auth, etc.)"""

    def __init__(self, threshold: int = 10, window: int = 60):
        self.threshold = threshold
        self.window = window  # seconds

        # Track failed attempts per (src_ip, service)
        self.attempts: Dict[str, deque] = defaultdict(lambda: deque())

        # Common services to monitor
        self.services = {
            22: 'SSH',
            21: 'FTP',
            23: 'Telnet',
            3389: 'RDP',
            5900: 'VNC',
            3306: 'MySQL',
            5432: 'PostgreSQL',
            1433: 'MSSQL'
        }

        self._lock = threading.Lock()

    def check_packet(self, packet: PacketInfo) -> Optional[Tuple[str, int]]:
        """
        Check for brute force indicators.
        Returns (service_name, attempt_count) if threshold exceeded.
        """
        if packet.dst_port not in self.services:
            return None

        service = self.services[packet.dst_port]
        key = f"{packet.src_ip}:{service}"

        with self._lock:
            # Clean old entries
            current_time = time.time()
            attempts = self.attempts[key]
            while attempts and current_time - attempts[0] > self.window:
                attempts.popleft()

            # Add this attempt
            attempts.append(current_time)

            # Check threshold
            if len(attempts) >= self.threshold:
                return (service, len(attempts))

        return None


class DDoSDetector:
    """Detects Distributed Denial of Service attacks"""

    def __init__(self):
        self.thresholds = {
            'syn_flood_pps': 1000,
            'udp_flood_pps': 5000,
            'icmp_flood_pps': 1000,
            'unique_src_ips': 100,  # In short time
            'amplification_ratio': 10
        }

        # Tracking windows (per second)
        self.syn_count: deque = deque(maxlen=60)
        self.udp_count: deque = deque(maxlen=60)
        self.icmp_count: deque = deque(maxlen=60)
        self.source_ips: deque = deque(maxlen=60)

        self._current_second = {
            'syn': 0,
            'udp': 0,
            'icmp': 0,
            'ips': set()
        }
        self._last_second = int(time.time())
        self._lock = threading.Lock()

    def check_packet(self, packet: PacketInfo) -> List[Tuple[str, Severity]]:
        """Check for DDoS indicators"""
        alerts = []

        with self._lock:
            self._update_counters(packet)
            alerts.extend(self._check_floods())

        return alerts

    def _update_counters(self, packet: PacketInfo):
        """Update DDoS tracking counters"""
        current = int(time.time())

        if current != self._last_second:
            # Store previous second's data
            self.syn_count.append(self._current_second['syn'])
            self.udp_count.append(self._current_second['udp'])
            self.icmp_count.append(self._current_second['icmp'])
            self.source_ips.append(len(self._current_second['ips']))

            # Reset counters
            self._current_second = {'syn': 0, 'udp': 0, 'icmp': 0, 'ips': set()}
            self._last_second = current

        # Count by type
        if packet.protocol == Protocol.TCP:
            if packet.flags & 0x02:  # SYN flag
                self._current_second['syn'] += 1

        elif packet.protocol == Protocol.UDP:
            self._current_second['udp'] += 1

        elif packet.protocol == Protocol.ICMP:
            self._current_second['icmp'] += 1

        self._current_second['ips'].add(packet.src_ip)

    def _check_floods(self) -> List[Tuple[str, Severity]]:
        """Check for flood attacks"""
        alerts = []

        if len(self.syn_count) < 5:
            return alerts

        # SYN flood
        avg_syn = statistics.mean(self.syn_count) if self.syn_count else 0
        if avg_syn > self.thresholds['syn_flood_pps']:
            alerts.append((
                f"SYN flood detected: {avg_syn:.0f} SYN packets/second",
                Severity.CRITICAL
            ))

        # UDP flood
        avg_udp = statistics.mean(self.udp_count) if self.udp_count else 0
        if avg_udp > self.thresholds['udp_flood_pps']:
            alerts.append((
                f"UDP flood detected: {avg_udp:.0f} UDP packets/second",
                Severity.CRITICAL
            ))

        # ICMP flood
        avg_icmp = statistics.mean(self.icmp_count) if self.icmp_count else 0
        if avg_icmp > self.thresholds['icmp_flood_pps']:
            alerts.append((
                f"ICMP flood detected: {avg_icmp:.0f} ICMP packets/second",
                Severity.HIGH
            ))

        # Many unique sources (distributed attack)
        avg_ips = statistics.mean(self.source_ips) if self.source_ips else 0
        if avg_ips > self.thresholds['unique_src_ips']:
            alerts.append((
                f"Possible DDoS: {avg_ips:.0f} unique source IPs/second",
                Severity.CRITICAL
            ))

        return alerts


class AlertManager:
    """Manages alerts generated by the IDS"""

    def __init__(self, max_alerts: int = 10000):
        self.alerts: deque = deque(maxlen=max_alerts)
        self.alert_callbacks: List[Callable[[Alert], None]] = []
        self._alert_counter = 0
        self._lock = threading.Lock()

        # Alert statistics
        self.stats = defaultdict(int)

        # Alert deduplication
        self._recent_hashes: deque = deque(maxlen=1000)

    def register_callback(self, callback: Callable[[Alert], None]):
        """Register a callback for new alerts"""
        self.alert_callbacks.append(callback)

    def create_alert(self, alert_type: AlertType, severity: Severity,
                     packet: PacketInfo, description: str,
                     signature_id: str = None, additional_info: Dict = None) -> Alert:
        """Create and store a new alert"""
        with self._lock:
            self._alert_counter += 1
            alert_id = f"ALERT-{self._alert_counter:08d}"

        alert = Alert(
            id=alert_id,
            timestamp=time.time(),
            alert_type=alert_type,
            severity=severity,
            source_ip=packet.src_ip,
            destination_ip=packet.dst_ip,
            source_port=packet.src_port,
            destination_port=packet.dst_port,
            protocol=packet.protocol,
            description=description,
            signature_id=signature_id,
            raw_packet=packet.raw,
            additional_info=additional_info or {}
        )

        # Deduplication check
        alert_hash = hashlib.md5(
            f"{alert.source_ip}{alert.alert_type}{description}".encode()
        ).hexdigest()

        with self._lock:
            if alert_hash not in self._recent_hashes:
                self._recent_hashes.append(alert_hash)
                self.alerts.append(alert)
                self.stats[alert_type.name] += 1
                self.stats[severity.name] += 1
                self.stats['total'] += 1

                # Call registered callbacks
                for callback in self.alert_callbacks:
                    try:
                        callback(alert)
                    except Exception as e:
                        logger.error(f"Alert callback error: {e}")

                return alert

        return None  # Duplicate

    def get_alerts(self, limit: int = 100, severity: Severity = None,
                   alert_type: AlertType = None) -> List[Alert]:
        """Get recent alerts with optional filtering"""
        with self._lock:
            alerts = list(self.alerts)

        if severity:
            alerts = [a for a in alerts if a.severity.value >= severity.value]

        if alert_type:
            alerts = [a for a in alerts if a.alert_type == alert_type]

        return alerts[-limit:]

    def get_stats(self) -> Dict:
        """Get alert statistics"""
        with self._lock:
            return dict(self.stats)


class IntrusionDetectionSystem:
    """
    Main IDS class combining all detection engines.

    Features:
    - Signature-based detection
    - Anomaly-based detection
    - Port scan detection
    - Brute force detection
    - DDoS detection
    - Real-time alerting
    """

    def __init__(self):
        self.running = False

        # Detection engines
        self.signature_engine = SignatureEngine()
        self.anomaly_engine = AnomalyEngine()
        self.bruteforce_detector = BruteForceDetector()
        self.ddos_detector = DDoSDetector()

        # Alert management
        self.alert_manager = AlertManager()

        # Statistics
        self.stats = {
            'packets_processed': 0,
            'alerts_generated': 0,
            'start_time': None
        }

        self._lock = threading.Lock()

    def start(self):
        """Start the IDS"""
        self.running = True
        self.stats['start_time'] = time.time()

        # Load default signatures
        self.signature_engine.load_default_signatures()

        logger.info("IDS started")

    def stop(self):
        """Stop the IDS"""
        self.running = False
        logger.info("IDS stopped")

    def process_packet(self, data: bytes) -> List[Alert]:
        """
        Process a packet through all detection engines.
        Returns list of generated alerts.
        """
        if not self.running:
            return []

        try:
            packet = PacketInfo.parse(data)
        except Exception as e:
            logger.debug(f"Failed to parse packet: {e}")
            return []

        with self._lock:
            self.stats['packets_processed'] += 1

        alerts = []

        # Signature-based detection
        sig_matches = self.signature_engine.check_packet(packet)
        for sig, matched_content in sig_matches:
            alert = self.alert_manager.create_alert(
                AlertType.SIGNATURE_MATCH,
                sig.severity,
                packet,
                f"{sig.name}: {sig.description}",
                signature_id=sig.id,
                additional_info={'matched_content': matched_content, 'category': sig.category}
            )
            if alert:
                alerts.append(alert)

        # Anomaly-based detection
        anomalies = self.anomaly_engine.analyze_packet(packet)
        for alert_type, description, severity in anomalies:
            alert = self.alert_manager.create_alert(
                alert_type,
                severity,
                packet,
                description
            )
            if alert:
                alerts.append(alert)

        # Brute force detection
        bf_result = self.bruteforce_detector.check_packet(packet)
        if bf_result:
            service, count = bf_result
            alert = self.alert_manager.create_alert(
                AlertType.BRUTE_FORCE,
                Severity.HIGH,
                packet,
                f"Brute force attack on {service}: {count} attempts from {packet.src_ip}",
                additional_info={'service': service, 'attempt_count': count}
            )
            if alert:
                alerts.append(alert)

        # DDoS detection
        ddos_alerts = self.ddos_detector.check_packet(packet)
        for description, severity in ddos_alerts:
            alert = self.alert_manager.create_alert(
                AlertType.DDOS_ATTACK,
                severity,
                packet,
                description
            )
            if alert:
                alerts.append(alert)

        with self._lock:
            self.stats['alerts_generated'] += len(alerts)

        return alerts

    def add_custom_signature(self, sig: Signature):
        """Add a custom detection signature"""
        self.signature_engine.load_signature(sig)

    def get_stats(self) -> Dict:
        """Get IDS statistics"""
        with self._lock:
            stats = dict(self.stats)

        stats['signature_count'] = len(self.signature_engine.signatures)
        stats['alert_stats'] = self.alert_manager.get_stats()
        stats['baseline_stats'] = self.anomaly_engine.get_baseline_stats()

        if stats['start_time']:
            stats['uptime'] = time.time() - stats['start_time']

        return stats

    def get_alerts(self, **kwargs) -> List[Alert]:
        """Get alerts from alert manager"""
        return self.alert_manager.get_alerts(**kwargs)


def create_test_packet(src_ip: str, dst_ip: str, src_port: int, dst_port: int,
                       payload: bytes = b'', protocol: Protocol = Protocol.TCP,
                       flags: int = 0x02) -> bytes:
    """Create a test packet for IDS testing"""
    # IP header
    version_ihl = (4 << 4) | 5
    tos = 0
    ip_length = 40 + len(payload) if protocol == Protocol.TCP else 28 + len(payload)
    identification = 12345
    flags_fragment = 0x4000
    ttl = 64
    proto = protocol.value
    checksum = 0
    src = socket.inet_aton(src_ip)
    dst = socket.inet_aton(dst_ip)

    ip_header = struct.pack('!BBHHHBBH4s4s',
        version_ihl, tos, ip_length, identification,
        flags_fragment, ttl, proto, checksum, src, dst
    )

    if protocol == Protocol.TCP:
        seq = 0
        ack = 0
        data_offset_flags = (5 << 12) | flags
        window = 65535
        tcp_checksum = 0
        urgent = 0

        tcp_header = struct.pack('!HHIIHHHH',
            src_port, dst_port, seq, ack,
            data_offset_flags, window, tcp_checksum, urgent
        )
        return ip_header + tcp_header + payload

    elif protocol == Protocol.UDP:
        length = 8 + len(payload)
        udp_checksum = 0

        udp_header = struct.pack('!HHHH',
            src_port, dst_port, length, udp_checksum
        )
        return ip_header + udp_header + payload

    return ip_header


def main():
    """Main entry point for IDS"""
    import argparse

    parser = argparse.ArgumentParser(description='Electroduction IDS')
    parser.add_argument('mode', choices=['test', 'demo', 'monitor'],
                        help='Run mode')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Enable verbose logging')

    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    if args.mode == 'test':
        run_tests()
    elif args.mode == 'demo':
        run_demo()
    elif args.mode == 'monitor':
        run_monitor()


def run_tests():
    """Run IDS component tests"""
    print("\n" + "="*60)
    print("INTRUSION DETECTION SYSTEM TESTS")
    print("="*60 + "\n")

    # Test 1: Packet Parsing
    print("[1] Testing Packet Parsing...")
    packet_data = create_test_packet("192.168.1.100", "10.0.0.1", 12345, 80, b"GET / HTTP/1.1")
    packet = PacketInfo.parse(packet_data)
    assert packet.src_ip == "192.168.1.100"
    assert packet.dst_ip == "10.0.0.1"
    assert packet.protocol == Protocol.TCP
    print("    Packet parsing PASSED")

    # Test 2: Signature Engine
    print("[2] Testing Signature Engine...")
    sig_engine = SignatureEngine()
    sig_engine.load_default_signatures()

    # Test SQL injection detection
    sqli_packet = create_test_packet(
        "192.168.1.100", "10.0.0.1", 12345, 80,
        b"GET /page?id=1' UNION SELECT * FROM users-- HTTP/1.1"
    )
    sqli_info = PacketInfo.parse(sqli_packet)
    matches = sig_engine.check_packet(sqli_info)
    assert len(matches) > 0
    assert any('SQL' in m[0].name for m in matches)
    print("    SQL injection detection PASSED")

    # Test XSS detection
    xss_packet = create_test_packet(
        "192.168.1.100", "10.0.0.1", 12345, 80,
        b"GET /page?q=<script>alert('xss')</script> HTTP/1.1"
    )
    xss_info = PacketInfo.parse(xss_packet)
    matches = sig_engine.check_packet(xss_info)
    assert len(matches) > 0
    print("    XSS detection PASSED")

    # Test 3: Anomaly Engine
    print("[3] Testing Anomaly Engine...")
    anomaly_engine = AnomalyEngine()

    # Feed baseline data
    for i in range(200):
        normal_packet = create_test_packet(
            f"192.168.1.{i % 10}", "10.0.0.1",
            50000 + i, 80, b"A" * 100
        )
        anomaly_engine.analyze_packet(PacketInfo.parse(normal_packet))

    baseline = anomaly_engine.get_baseline_stats()
    assert baseline['sample_size'] >= 200
    print("    Anomaly baseline PASSED")

    # Test 4: Port Scan Detection
    print("[4] Testing Port Scan Detection...")
    # Simulate port scan
    for port in range(1, 50):
        scan_packet = create_test_packet(
            "10.20.30.40", "192.168.1.1", 54321, port
        )
        anomalies = anomaly_engine.analyze_packet(PacketInfo.parse(scan_packet))

    # Check if port scan was detected
    assert len(anomaly_engine.ip_stats["10.20.30.40"]['unique_ports']) >= 49
    print("    Port scan tracking PASSED")

    # Test 5: Brute Force Detection
    print("[5] Testing Brute Force Detection...")
    bf_detector = BruteForceDetector(threshold=5, window=60)

    for i in range(10):
        ssh_packet = create_test_packet("10.0.0.100", "192.168.1.1", 54321, 22)
        result = bf_detector.check_packet(PacketInfo.parse(ssh_packet))

    assert result is not None
    assert result[0] == 'SSH'
    print("    Brute force detection PASSED")

    # Test 6: Alert Manager
    print("[6] Testing Alert Manager...")
    alert_manager = AlertManager()

    test_packet = PacketInfo.parse(create_test_packet("1.2.3.4", "5.6.7.8", 1234, 80))
    alert = alert_manager.create_alert(
        AlertType.SIGNATURE_MATCH,
        Severity.HIGH,
        test_packet,
        "Test alert"
    )
    assert alert is not None
    assert alert.severity == Severity.HIGH

    stats = alert_manager.get_stats()
    assert stats['total'] >= 1
    print("    Alert manager PASSED")

    # Test 7: Full IDS Integration
    print("[7] Testing Full IDS Integration...")
    ids = IntrusionDetectionSystem()
    ids.start()

    attack_packet = create_test_packet(
        "10.0.0.1", "192.168.1.1", 12345, 80,
        b"GET /admin.php?cmd=;cat /etc/passwd HTTP/1.1"
    )

    alerts = ids.process_packet(attack_packet)
    # Should detect command injection
    print(f"    Generated {len(alerts)} alerts")

    ids.stop()
    print("    Full integration PASSED")

    print("\n" + "="*60)
    print("ALL TESTS PASSED!")
    print("="*60 + "\n")


def run_demo():
    """Run IDS demonstration"""
    print("\n" + "="*70)
    print("   ELECTRODUCTION IDS - DEMONSTRATION")
    print("="*70 + "\n")

    # Initialize IDS
    print("[1] Initializing Intrusion Detection System...")
    ids = IntrusionDetectionSystem()

    # Add alert callback
    def print_alert(alert: Alert):
        severity_colors = {
            Severity.INFO: "",
            Severity.LOW: "",
            Severity.MEDIUM: "[!]",
            Severity.HIGH: "[!!]",
            Severity.CRITICAL: "[!!!]"
        }
        prefix = severity_colors.get(alert.severity, "")
        print(f"    ALERT {prefix} [{alert.severity.name}] {alert.description}")

    ids.alert_manager.register_callback(print_alert)
    ids.start()
    print(f"    Loaded {len(ids.signature_engine.signatures)} signatures")
    print()

    # Generate baseline traffic
    print("[2] Generating baseline traffic (normal activity)...")
    for i in range(100):
        normal_packet = create_test_packet(
            f"192.168.1.{(i % 10) + 1}",
            "10.0.0.1",
            50000 + i, 80,
            b"GET /index.html HTTP/1.1\r\nHost: example.com\r\n\r\n"
        )
        ids.process_packet(normal_packet)
    print("    Baseline established")
    print()

    # Simulate attacks
    print("[3] Simulating Attack Scenarios...\n")

    attacks = [
        ("SQL Injection", "192.168.1.100", 80,
         b"GET /search?q=' OR '1'='1 HTTP/1.1\r\n"),
        ("SQL Injection UNION", "192.168.1.101", 80,
         b"GET /user?id=1 UNION SELECT username,password FROM users HTTP/1.1\r\n"),
        ("XSS Attack", "192.168.1.102", 80,
         b"POST /comment HTTP/1.1\r\n\r\n<script>document.cookie</script>"),
        ("Command Injection", "192.168.1.103", 80,
         b"GET /ping?host=127.0.0.1;cat /etc/passwd HTTP/1.1\r\n"),
        ("Path Traversal", "192.168.1.104", 80,
         b"GET /download?file=../../../etc/passwd HTTP/1.1\r\n"),
        ("Webshell Indicator", "192.168.1.105", 80,
         b"POST /shell.php HTTP/1.1\r\n\r\neval($_POST['cmd'])"),
    ]

    for attack_name, src_ip, port, payload in attacks:
        print(f"  [{attack_name}]")
        print(f"    Source: {src_ip}")
        packet = create_test_packet(src_ip, "10.0.0.1", 54321, port, payload)
        alerts = ids.process_packet(packet)
        if not alerts:
            print("    No alerts (may be deduplicated)")
        print()
        time.sleep(0.2)

    # Simulate port scan
    print("[4] Simulating Port Scan...")
    print("    Attacker: 10.20.30.40")
    print("    Target: 192.168.1.1")
    for port in range(1, 100):
        scan_packet = create_test_packet(
            "10.20.30.40", "192.168.1.1",
            12345, port,
            flags=0x02  # SYN
        )
        ids.process_packet(scan_packet)
    print()

    # Simulate brute force
    print("[5] Simulating SSH Brute Force...")
    print("    Attacker: 10.0.0.200")
    print("    Target: 192.168.1.1:22 (SSH)")
    for i in range(15):
        ssh_packet = create_test_packet(
            "10.0.0.200", "192.168.1.1",
            54321 + i, 22,
            b"SSH-2.0-OpenSSH_8.0"
        )
        ids.process_packet(ssh_packet)
    print()

    # Show statistics
    print("[6] IDS Statistics:")
    stats = ids.get_stats()
    print(f"    Packets Processed: {stats['packets_processed']}")
    print(f"    Alerts Generated: {stats['alerts_generated']}")
    print(f"    Signatures Loaded: {stats['signature_count']}")
    print(f"    Baseline Sample Size: {stats['baseline_stats']['sample_size']}")
    print()

    print("    Alert Breakdown:")
    for key, value in stats['alert_stats'].items():
        if value > 0:
            print(f"      {key}: {value}")
    print()

    # Show recent alerts
    print("[7] Recent High-Severity Alerts:")
    recent_alerts = ids.get_alerts(limit=10, severity=Severity.HIGH)
    for alert in recent_alerts:
        print(f"    [{alert.id}] {alert.severity.name}: {alert.description[:60]}...")
    print()

    ids.stop()

    print("="*70)
    print("   DEMO COMPLETED")
    print("="*70 + "\n")


def run_monitor():
    """Run IDS in monitor mode (simulated)"""
    print("\n" + "="*60)
    print("IDS MONITOR MODE (Simulation)")
    print("="*60)
    print("\nMonitoring network traffic...")
    print("Press Ctrl+C to stop\n")

    ids = IntrusionDetectionSystem()

    def alert_handler(alert: Alert):
        timestamp = datetime.fromtimestamp(alert.timestamp).strftime("%H:%M:%S")
        print(f"[{timestamp}] [{alert.severity.name:8s}] {alert.alert_type.name}: {alert.description}")

    ids.alert_manager.register_callback(alert_handler)
    ids.start()

    try:
        packet_count = 0
        while True:
            # Generate random traffic
            import random

            src_ip = f"192.168.1.{random.randint(1, 254)}"
            dst_ip = f"10.0.0.{random.randint(1, 254)}"
            src_port = random.randint(1024, 65535)
            dst_port = random.choice([80, 443, 22, 21, 25, 53, 3306])

            # Occasionally inject attack traffic
            if random.random() < 0.05:
                payloads = [
                    b"' OR '1'='1",
                    b"<script>alert(1)</script>",
                    b";cat /etc/passwd",
                    b"../../../etc/passwd",
                ]
                payload = random.choice(payloads)
            else:
                payload = b"normal traffic data"

            packet = create_test_packet(src_ip, dst_ip, src_port, dst_port, payload)
            ids.process_packet(packet)
            packet_count += 1

            if packet_count % 100 == 0:
                stats = ids.get_stats()
                print(f"\n--- Processed {packet_count} packets, {stats['alerts_generated']} alerts ---\n")

            time.sleep(0.01)

    except KeyboardInterrupt:
        print("\n\nStopping monitor...")
        ids.stop()
        stats = ids.get_stats()
        print(f"\nFinal Stats:")
        print(f"  Packets: {stats['packets_processed']}")
        print(f"  Alerts: {stats['alerts_generated']}")


if __name__ == "__main__":
    main()
